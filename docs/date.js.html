

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      Croner - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <link id="google-font" href="https://fonts.googleapis.com/css?family=Roboto+Mono|Cutive+Mono|Roboto:300,400,700" rel="stylesheet">
  <link type="text/css" rel="stylesheet" href="styles/highlight-themes/current.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <link type="text/css" rel="stylesheet" href="styles/collapsible.css">
  <link type="text/css" rel="stylesheet" href="styles/style-switcher.css">
  <link type="text/css" rel="stylesheet" href="styles/selectric.css">
  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
  <script src="https://embed.runkit.com"></script>
  <style id="style-switcher-styles">
    nav {
        background: #282c34;
    }
    .hljs {
        background: #1d2027;
    }
    .nav-container > ul > li.active a {
        color: #dcdcdc;
    }
    .nav-container > ul > li.active a:hover {
        color: #f78200;
    }
    .nav-container > ul > li.active ul {
        border-color: #f78200;
    }
    h4.name {
        color: #f78200;
    }
    .params > div > code, .params > div > em {
        color: #f78200;
    }
    a, a:active {
        color: #f78200;
    }
    .hljs-doctag, .hljs-keyword, .hljs-formula {
        color: #f78200;
    }
    nav ul a:hover, nav ul a:active {
        color: #f78200;
    }
  </style>
</head>

<body>
  <header class="header-fixed">
      <h1>
        <a href="index.html" title="modernTemplate.title">
            
                <img alt="Croner" src="https://cdn.jsdelivr.net/gh/hexagon/croner@master/croner.png" />
            
            Croner
        </a>
      </h1>
      <div class="center-header">
          <ul>
            
          </ul>
      </div>
      <div class="right-header">
           
                <a href="https://github.com/hexagon/croner" title="View it on Github" style="">
                    <i class="fab fa-github-alt"></i>
                </a>
           
                <a href="https://www.npmjs.com/package/croner" title="View it on NPM" style="font-size: 19px">
                    <i class="fas fa-exclamation-triangle"></i>
                </a>
           
      </div>
  </header>

  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <nav>
    <div id="menu-container" class="scrollbar-inner">
        <div class="nav-container">
            <h3>Classes</h3><ul><li id="Cron-nav"><a href="Cron.html">Cron</a><ul class='methods'><li data-type="method" id="Cron-enumerate-nav"><a href="Cron.html#enumerate">enumerate</a></li><li data-type="method" id="Cron-msToNext-nav"><a href="Cron.html#msToNext">msToNext</a></li><li data-type="method" id="Cron-next-nav"><a href="Cron.html#next">next</a></li><li data-type="method" id="Cron-pause-nav"><a href="Cron.html#pause">pause</a></li><li data-type="method" id="Cron-previous-nav"><a href="Cron.html#previous">previous</a></li><li data-type="method" id="Cron-resume-nav"><a href="Cron.html#resume">resume</a></li><li data-type="method" id="Cron-running-nav"><a href="Cron.html#running">running</a></li><li data-type="method" id="Cron-schedule-nav"><a href="Cron.html#schedule">schedule</a></li><li data-type="method" id="Cron-stop-nav"><a href="Cron.html#stop">stop</a></li></ul></li><li id="CronDate-nav"><a href="CronDate.html">CronDate</a><ul class='methods'><li data-type="method" id="CronDate-getDate-nav"><a href="CronDate.html#getDate">getDate</a></li><li data-type="method" id="CronDate-getTime-nav"><a href="CronDate.html#getTime">getTime</a></li><li data-type="method" id="CronDate-increment-nav"><a href="CronDate.html#increment">increment</a></li></ul></li><li id="CronPattern-nav"><a href="CronPattern.html">CronPattern</a></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#maxDelay">maxDelay</a></li></ul>
        </div>
    </div>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        date.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>import { minitz } from "./helpers/minitz.js";

// This import is only used by tsc for generating type definitions from js/jsdoc
// deno-lint-ignore no-unused-vars
import { CronOptions as CronOptions } from "./options.js"; // eslint-disable-line no-unused-vars


// Constant defining the minimum number of days per month where index 0 = January etc.
const DaysOfMonth = [31,28,31,30,31,30,31,31,30,31,30,31];

// Array of work to be done, consisting of subarrays described below:
// [
//   First item is which member to process,
//   Second item is which member to increment if we didn't find a mathch in current item,
//   Third item is an offset. if months is handled 0-11 in js date object, and we get 1-12
//   from pattern. Offset should be -1
// ]
const ToDo = [
	["m", "y", 0],
	["d", "m", -1],
	["h", "d", 0],
	["i", "h", 0],
	["s", "i", 0],
];
    
/**
 * Converts date to CronDate
 * @constructor
 * 
 * @param {CronDate|Date|string} [d] - Input date, if using string representation ISO 8001 (2015-11-24T19:40:00) local timezone is expected
 * @param {string} [tz] - String representation of target timezone in Europe/Stockholm format.
*/
function CronDate (d, tz) {	

	this.tz = tz;

	if (d &amp;&amp; d instanceof Date) {
		if (!isNaN(d)) {
			this.fromDate(d);
		} else {
			throw new TypeError("CronDate: Invalid date passed to CronDate constructor");
		}
	} else if (d === void 0) {
		this.fromDate(new Date());
	} else if (d &amp;&amp; typeof d === "string") {
		this.fromString(d);
	} else if (d instanceof CronDate) {
		this.fromCronDate(d);
	} else {
		throw new TypeError("CronDate: Invalid type (" + typeof d + ") passed to CronDate constructor");
	}

}

/**
 * Sets internals using a Date 
 * @private
 * 
 * @param {Date} inDate - Input date in local time
 */
CronDate.prototype.fromDate = function (inDate) {
	
	if (this.tz) {
		const d = minitz.toTZ(inDate, this.tz);
		this.ms = inDate.getMilliseconds();
		this.s = d.s;
		this.i = d.i;
		this.h = d.h;
		this.d = d.d;
		this.m  = d.m - 1;
		this.y = d.y;
	} else {
		this.ms = inDate.getMilliseconds();
		this.s = inDate.getSeconds();
		this.i = inDate.getMinutes();
		this.h = inDate.getHours();
		this.d = inDate.getDate();
		this.m  = inDate.getMonth();
		this.y = inDate.getFullYear();
	}

};

/**
 * Sets internals by deep copying another CronDate
 * @private
 * 
 * @param {CronDate} d - Input date
 */
CronDate.prototype.fromCronDate = function (d) {
	this.tz = d.tz;
	this.ms = d.ms;
	this.s = d.s;
	this.i = d.i;
	this.h = d.h;
	this.d = d.d;
	this.m = d.m;
	this.y = d.y;
};

/**
 * Reset internal parameters (seconds, minutes, hours) if any of them have exceeded (or could have exceeded) their ranges
 * @private
 */
CronDate.prototype.apply = function () {
	// If any value could be out of bounds, apply 
	if (this.m>11||this.d>DaysOfMonth[this.m]||this.h>59||this.i>59||this.s>59) {
		const d = new Date(Date.UTC(this.y, this.m, this.d, this.h, this.i, this.s, this.ms));
		this.ms = d.getUTCMilliseconds();
		this.s = d.getUTCSeconds();
		this.i = d.getUTCMinutes();
		this.h = d.getUTCHours();
		this.d = d.getUTCDate();
		this.m  = d.getUTCMonth();
		this.y = d.getUTCFullYear();
		return true;
	} else {
		return false;
	}
};

/**
 * Sets internals by parsing a string
 * @private
 * 
 * @param {Date} date - Input date
 */
CronDate.prototype.fromString = function (str) {
	return this.fromDate(minitz.fromTZISO(str, this.tz));
};

/**
 * Find next match of current part
 * @private
 *  
 * @param {CronOptions} options - Cron options used for incrementing
 * @param {string} target
 * @param {CronPattern} pattern
 * @param {Number} offset
 * 
 * @returns {boolean}
 * 
 */
CronDate.prototype.findNext = function (options, target, pattern, offset) {
	const originalTarget = this[target];

	// In the conditions below, local time is not relevant. And as new Date(Date.UTC(y,m,d)) is way faster 
	// than new Date(y,m,d). We use the UTC functions to set/get date parts.

	// Pre-calculate last day of month if needed
	let lastDayOfMonth;
	if (pattern.lastDayOfMonth) {
		if (this.m !== 1) {
			lastDayOfMonth = DaysOfMonth[this.m]; // About 20% performance increase when using L
		} else {
			lastDayOfMonth = new Date(Date.UTC(this.y, this.m+1, 0,0,0,0,0)).getUTCDate();
		}
	}

	// Pre-calculate weekday if needed
	// Calculate offset weekday by ((fDomWeekDay + (targetDate - 1)) % 7)
	const fDomWeekDay = (!pattern.starDOW &amp;&amp; target == "d") ? new Date(Date.UTC(this.y, this.m, 1,0,0,0,0)).getUTCDay() : undefined;

	for( let i = this[target] + offset; i &lt; pattern[target].length; i++ ) {

		// this applies to all "levels"
		let match = pattern[target][i];

		// Special case for last day of month
		if (target === "d" &amp;&amp; pattern.lastDayOfMonth &amp;&amp; i-offset == lastDayOfMonth) {
			match = true;
		}

		// Special case for day of week
		if (target === "d" &amp;&amp; !pattern.starDOW) {
			const dowMatch = pattern.dow[(fDomWeekDay + ((i-offset) - 1)) % 7];
			// If we use legacyMode, and dayOfMonth is specified - use "OR" to combine day of week with day of month
			// In all other cases use "AND"
			if (options.legacyMode &amp;&amp; !pattern.starDOM) {
				match = match || dowMatch;
			} else {
				match = match &amp;&amp; dowMatch;
			}
		}

		if (match) {
			this[target] = i-offset;
			if (originalTarget !== this[target]) {
				// Changed
				return 2;
			} else {
				// Unchanged
				return 1;
			}
		}
	}
	return 3;
};

/**
 * Increment to next run time recursively
 * @private
 * 
 * @param {string} pattern - The pattern used to increment current state
 * @param {CronOptions} options - Cron options used for incrementing
 * @param {integer} doing - Which part to increment, 0 represent first item of ToDo-array etc.
 * @return {CronDate|null} - Returns itthis for chaining, or null if increment wasnt possible
 */
CronDate.prototype.recurse = function (pattern, options, doing)  {

	// Find next month (or whichever part we're at)
	const res = this.findNext(options, ToDo[doing][0], pattern, ToDo[doing][2]);

	// Month (or whichever part we're at) changed
	if (res > 1) {
		// Flag following levels for reset
		let resetLevel = doing + 1;
		while(resetLevel &lt; ToDo.length) {
			this[ToDo[resetLevel][0]] = -ToDo[resetLevel][2];
			resetLevel++;
		}
		// Parent changed
		if (res=== 3) {
			// Do increment parent, and reset current level
			this[ToDo[doing][1]]++;
			this[ToDo[doing][0]] = -ToDo[doing][2];
			this.apply();

			// Restart
			return this.recurse(pattern, options, 0);
		} else if (this.apply()) {
			return this.recurse(pattern, options, doing-1);
		}

	}

	// Move to next level
	doing += 1;

	// Done?
	if (doing >= ToDo.length) {
		return this;

		// ... or out of bounds ?
	} else if (this.y >= 3000) {
		return null;

		// ... oh, go to next part then
	} else {

		return this.recurse(pattern, options, doing);
	}
    
};

/**
 * Increment to next run time
 * @public
 * 
 * @param {string} pattern - The pattern used to increment current state
 * @param {CronOptions} options - Cron options used for incrementing
 * @param {boolean} [hasPreviousRun] - If this run should adhere to minimum interval
 * @return {CronDate|null} - Returns itthis for chaining, or null if increment wasnt possible
 */
CronDate.prototype.increment = function (pattern, options, hasPreviousRun) {
	
	// Always add one second, or minimum interval, then clear milliseconds and apply changes if seconds has gotten out of bounds
	if (options.interval > 1 &amp;&amp; hasPreviousRun) {
		this.s += options.interval;
	} else {
		this.s += 1;
	}
	this.ms = 0;
	this.apply();


	return this.recurse(pattern, options, 0);
	
};

/**
 * Convert current state back to a javascript Date()
 * @public
 * 
 * @param {boolean} internal - If this is an internal call
 * @returns {Date}
 */
CronDate.prototype.getDate = function (internal) {
	if (internal || !this.tz) {
		return new Date(this.y, this.m, this.d, this.h, this.i, this.s, this.ms);
	} else {
		return minitz(this.y, this.m+1, this.d, this.h, this.i, this.s, this.tz);
	}
};

/**
 * Convert current state back to a javascript Date() and return UTC milliseconds
 * @public
 * 
 * @returns {Date}
 */
CronDate.prototype.getTime = function () {
	return this.getDate().getTime();
};

export { CronDate };</code></pre>
  </article>
</section>

    



  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a>
  </footer>

    

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>
  <script src="scripts/scrollbar.js"></script>
  <script src="scripts/collapsible.js"></script>
  <script src="scripts/jquery.selectric.min.js"></script>
  <script src="scripts/clipboard.min.js"></script>

  <script>hljs.initHighlightingOnLoad();</script>

  
  <script>
      $(function () {
          $('#menu-container').scrollbar();

          
      });
    </script>
</body>
</html>
