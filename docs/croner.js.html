

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      Croner - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  <link id="google-font" href="https://fonts.googleapis.com/css?family=Roboto+Mono|Cutive+Mono|Roboto:300,400,700" rel="stylesheet">
  <link type="text/css" rel="stylesheet" href="styles/highlight-themes/current.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <link type="text/css" rel="stylesheet" href="styles/collapsible.css">
  <link type="text/css" rel="stylesheet" href="styles/style-switcher.css">
  <link type="text/css" rel="stylesheet" href="styles/selectric.css">
  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
  <script src="https://embed.runkit.com"></script>
  <style id="style-switcher-styles">
    nav {
        background: #282c34;
    }
    .hljs {
        background: #1d2027;
    }
    .nav-container > ul > li.active a {
        color: #dcdcdc;
    }
    .nav-container > ul > li.active a:hover {
        color: #f78200;
    }
    .nav-container > ul > li.active ul {
        border-color: #f78200;
    }
    h4.name {
        color: #f78200;
    }
    .params > div > code, .params > div > em {
        color: #f78200;
    }
    a, a:active {
        color: #f78200;
    }
    .hljs-doctag, .hljs-keyword, .hljs-formula {
        color: #f78200;
    }
    nav ul a:hover, nav ul a:active {
        color: #f78200;
    }
  </style>
</head>

<body>
  <header class="header-fixed">
      <h1>
        <a href="index.html" title="modernTemplate.title">
            
                <img alt="Croner" src="https://cdn.jsdelivr.net/gh/hexagon/croner@master/croner.png" />
            
            Croner
        </a>
      </h1>
      <div class="center-header">
          <ul>
            
          </ul>
      </div>
      <div class="right-header">
           
                <a href="https://github.com/hexagon/croner" title="View it on Github" style="">
                    <i class="fab fa-github-alt"></i>
                </a>
           
                <a href="https://www.npmjs.com/package/croner" title="View it on NPM" style="font-size: 19px">
                    <i class="fas fa-exclamation-triangle"></i>
                </a>
           
      </div>
  </header>

  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <nav>
    <div id="menu-container" class="scrollbar-inner">
        <div class="nav-container">
            <h3>Classes</h3><ul><li id="Cron-nav"><a href="Cron.html">Cron</a><ul class='methods'><li data-type="method" id="Cron-enumerate-nav"><a href="Cron.html#enumerate">enumerate</a></li><li data-type="method" id="Cron-msToNext-nav"><a href="Cron.html#msToNext">msToNext</a></li><li data-type="method" id="Cron-next-nav"><a href="Cron.html#next">next</a></li><li data-type="method" id="Cron-pause-nav"><a href="Cron.html#pause">pause</a></li><li data-type="method" id="Cron-previous-nav"><a href="Cron.html#previous">previous</a></li><li data-type="method" id="Cron-resume-nav"><a href="Cron.html#resume">resume</a></li><li data-type="method" id="Cron-running-nav"><a href="Cron.html#running">running</a></li><li data-type="method" id="Cron-schedule-nav"><a href="Cron.html#schedule">schedule</a></li><li data-type="method" id="Cron-stop-nav"><a href="Cron.html#stop">stop</a></li></ul></li><li id="CronDate-nav"><a href="CronDate.html">CronDate</a><ul class='methods'><li data-type="method" id="CronDate-getDate-nav"><a href="CronDate.html#getDate">getDate</a></li><li data-type="method" id="CronDate-getTime-nav"><a href="CronDate.html#getTime">getTime</a></li><li data-type="method" id="CronDate-increment-nav"><a href="CronDate.html#increment">increment</a></li></ul></li><li id="CronPattern-nav"><a href="CronPattern.html">CronPattern</a></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#maxDelay">maxDelay</a></li></ul>
        </div>
    </div>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        croner.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>/* ------------------------------------------------------------------------------------

  Croner - MIT License - Hexagon &lt;github.com/Hexagon>

  Pure JavaScript Isomorphic cron parser and scheduler without dependencies.

  ------------------------------------------------------------------------------------

  License:

	Copyright (c) 2015-2022 Hexagon &lt;github.com/Hexagon>

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.

  ------------------------------------------------------------------------------------  */
import { CronDate } from "./date.js";
import { CronPattern } from "./pattern.js";
import { CronOptions } from "./options.js";

/**
 * Many JS engines stores the delay as a 32-bit signed integer internally.
 * This causes an integer overflow when using delays larger than 2147483647, 
 * resulting in the timeout being executed immediately.
 * 
 * All JS engines implements an immediate execution of delays larger that a 32-bit 
 * int to keep the behaviour concistent. 
 * 
 * @constant
 * @type {number}
 */
const maxDelay = Math.pow(2, 32 - 1) - 1;

/**
 * Cron entrypoint
 * 
 * @constructor
 * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string
 * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern
 * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern
 * @returns {Cron}
 */
function Cron (pattern, fnOrOptions1, fnOrOptions2) {
	
	// Optional "new" keyword
	if( !(this instanceof Cron) ) {
		return new Cron(pattern, fnOrOptions1, fnOrOptions2);
	}
	
	// Make options and func optional and interchangable
	let options, func;

	if( typeof fnOrOptions1 === "function" ) {
		func = fnOrOptions1;
	} else if( typeof fnOrOptions1 === "object" ) {
		options = fnOrOptions1;
	} else if( fnOrOptions1 !== void 0) {
		throw new Error("Cron: Invalid argument passed for optionsIn. Should be one of function, or object (options).");
	}

	if( typeof fnOrOptions2 === "function" ) {
		func = fnOrOptions2;
	} else if( typeof fnOrOptions2 === "object" ) {
		options = fnOrOptions2;
	} else if( fnOrOptions2 !== void 0) {
		throw new Error("Cron: Invalid argument passed for funcIn. Should be one of function, or object (options).");
	}
	
	/** @type {CronOptions} */
	this.options = CronOptions(options);
	
	/** @type {CronDate|undefined} */
	this.once = void 0;
	
	/** @type {CronPattern|undefined} */
	this.pattern = void 0;
	
	// Check if we got a date, or a pattern supplied as first argument
	// Then set either this.once or this.pattern
	if (pattern &amp;&amp; (pattern instanceof Date || ((typeof pattern === "string") &amp;&amp; pattern.indexOf(":") > 0))) {
		this.once = new CronDate(pattern, this.options.timezone);
	} else {
		this.pattern = new CronPattern(pattern, this.options.timezone);
	}
	
	// Allow shorthand scheduling
	if( func !== void 0 ) {
		this.fn = func;
		this.schedule();
	}
	
	return this;
	
}
	
/**
 * Find next runtime, based on supplied date. Strips milliseconds.
 * 
 * @param {CronDate|Date|string} [prev] - Date to start from
 * @returns {Date | null} - Next run time
 */
Cron.prototype.next = function (prev) {
	const next = this._next(prev);
	return next ? next.getDate() : null;
};
	
/**
 * Find next n runs, based on supplied date. Strips milliseconds.
 * 
 * @param {number} n - Number of runs to enumerate
 * @param {Date|string} [previous] - Date to start from
 * @returns {Date[]} - Next n run times
 */
Cron.prototype.enumerate = function (n, previous) {
	if(n > this.options.maxRuns){
		n = this.options.maxRuns;
	}
	const enumeration = [];
	let prev = previous || this.previousrun;
	while(n-- &amp;&amp; (prev = this.next(prev))) {
		enumeration.push(prev);
	}
	
	return enumeration;
};
	
/**
 * Is running?
 * @public
 * 
 * @returns {boolean} - Running or not
 */
Cron.prototype.running = function () {
	const msLeft = this.msToNext(this.previousrun);
	const running = !this.options.paused &amp;&amp; this.fn !== void 0;
	return msLeft !== null &amp;&amp; running;
};
	
/**
 * Return previous run time
 * @public
 * 
 * @returns {Date | null} - Previous run time
 */
Cron.prototype.previous = function () {
	return this.previousrun ? this.previousrun.getDate() : null;
};
	
/**
 * Returns number of milliseconds to next run
 * @public
 * 
 * @param {CronDate|Date|string} [prev] - Starting date, defaults to now - minimum interval
 * @returns {number | null}
 */
Cron.prototype.msToNext = function (prev) {

	// Get next run time
	const next = this._next(prev || this.previousrun);

	// Default previous for millisecond calculation
	prev = new CronDate(prev, this.options.timezone);

	if( next ) {
		return (next.getTime(true) - prev.getTime(true));
	} else {
		return null;
	}
};
	
/**
 * Stop execution 
 * @public
 */
Cron.prototype.stop = function () {
	this.options.kill = true;
	// Stop any awaiting call
	if( this.currentTimeout ) {
		clearTimeout( this.currentTimeout );
	}
};
	
/**
 * Pause execution
 * @public
 * 
 * @returns {boolean} - Wether pause was successful
 */
Cron.prototype.pause = function () {
	return (this.options.paused = true) &amp;&amp; !this.options.kill;
};
	
/**
 * Resume execution
 * @public
 * 
 * @returns {boolean} - Wether resume was successful
 */
Cron.prototype.resume = function () {
	return !(this.options.paused = false) &amp;&amp; !this.options.kill;
};
	
/**
 * Schedule a new job
 * @public
 * 
 * @param {Function} func - Function to be run each iteration of pattern
 * @param {Date} [partial] - Internal function indicating a partial run
 * @returns {Cron}
 */
Cron.prototype.schedule = function (func, partial) {
	
	// If a function is already scheduled, bail out
	if (func &amp;&amp; this.fn) {
		throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.");
		
		// Update function if passed
	} else if (func) {
		this.fn = func;
	}
	
	// Get ms to next run, bail out early if waitMs is null (no next run)
	let	waitMs = this.msToNext(partial ? partial : this.previousrun);
	const target = this.next(partial ? partial :  this.previousrun);

	if  ( waitMs === null )  return this;
	
	// setTimeout cant handle more than Math.pow(2, 32 - 1) - 1 ms
	if( waitMs > maxDelay ) {
		waitMs = maxDelay;
	}
	
	// Ok, go!
	this.currentTimeout = setTimeout(() => {
	
		const now = new Date();

		if( waitMs !== maxDelay &amp;&amp; !this.options.paused &amp;&amp; now.getTime() >= target ) {
	
			this.options.maxRuns--;
	
			// Always catch errors, but only re-throw if options.catch is not set
			if (this.options.catch) {
				try {
					this.fn(this, this.options.context);
				} catch (_e) {
					// Ignore
				}
			} else {
				this.fn(this, this.options.context);
			}
	
			// Set previous run to now
			this.previousrun = new CronDate(void 0, this.options.timezone);
	
			// Recurse
			this.schedule();
			
		} else {
			// Partial
			this.schedule(undefined, now);
		}
	
	
	}, waitMs);
		
	return this;
	
};

	
/**
 * Internal version of next. Cron needs millseconds internally, hence _next.
 * @private
 * 
 * @param {CronDate|Date|string} prev - PreviousRun
 * @returns {CronDate | null} - Next run time
 */
Cron.prototype._next = function (prev) {

	const hasPreviousRun = (prev || this.previousrun) ? true : false;

	// Ensure previous run is a CronDate
	prev = new CronDate(prev, this.options.timezone);

	// Previous run should never be before startAt
	if( this.options.startAt &amp;&amp; prev &amp;&amp; prev.getTime() &lt; this.options.startAt.getTime() ) {
		prev = this.options.startAt;
	}

	// Calculate next run according to pattern or one-off timestamp, pass actual previous run to increment
	const 
		nextRun = this.once || new CronDate(prev, this.options.timezone).increment(this.pattern, this.options, hasPreviousRun);
	
	if (this.once &amp;&amp; this.once.getTime() &lt;= prev.getTime()) {
		return null;
  
	} else if ((nextRun === null) ||
		(this.options.maxRuns &lt;= 0) ||	
		(this.options.kill) ||
		(this.options.stopAt &amp;&amp; nextRun.getTime() >= this.options.stopAt.getTime() )) {
		return null;

	} else {
		// All seem good, return next run
		return nextRun;

	}
		
};

Cron.Cron = Cron;
export default Cron;
export { Cron };
</code></pre>
  </article>
</section>

    



  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a>
  </footer>

    

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>
  <script src="scripts/scrollbar.js"></script>
  <script src="scripts/collapsible.js"></script>
  <script src="scripts/jquery.selectric.min.js"></script>
  <script src="scripts/clipboard.min.js"></script>

  <script>hljs.initHighlightingOnLoad();</script>

  
  <script>
      $(function () {
          $('#menu-container').scrollbar();

          
      });
    </script>
</body>
</html>
